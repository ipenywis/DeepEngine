#pragma once

#include <map>
#include <vector>
#include "GLTexture.h"
#include "ResourceManager.h"
#include <glm\glm.hpp>
#include "SpriteBatch.h"
#include "TileSheet.h"
#include "Camera2D.h"
#include "DebugRenderer.h"
#include "LoadUV.h"
#include "Window.h"

#include <random>

#include <TMXParser\Tmx.h>

#include "SDLRenderer.h"
#include "SDLTextureManager.h"

/*
* This Class is for handling TMX Tiled Map Parsing and Rendering Using Opengl, SDL
* Part of Deep Engine  Game Engine [ API ] 
* TMX File is an XML data File Generated By Tiled Map Editor ... Which means actually a specific Level to parse and Render  
*/

namespace Deep {

	class LevelManager
	{
	public:

		LevelManager();
		LevelManager(const std::string& fileName, const std::string& UVFileName, Deep::Camera2D& camera);
		~LevelManager();

		void init(Deep::LoadUV* loadUV, const std::string& fileName, const std::string& UVFileName, Deep::Window* window, Deep::Camera2D& camera, const glm::ivec2& sheetDims, bool useID = false);
		void OpenGLDraw();
		void drawBackgrounds(glm::vec4& uvRect, Deep::Camera2D& camera);
		void drawobject(Deep::SpriteBatch& spriteBatch, const std::string& objectName, glm::vec2& dims ,glm::vec4& UVRect, Deep::GLTexture& texture, Deep::ColorRGBA8 color = Deep::ColorRGBA8(255, 255, 255, 255));
		void SDLDraw();
		void drawObjects(const std::string EllipseTexture = "");
		void render();
		void dispose();

		// Parsing 
		void parseMap();
		void parseLayer();
		void parseTileSet();
		void parseTileLayer();
		void parseObject();

		glm::vec4& mappingSystem(int tileID, int numTiles, int numROWTiles, int numROWs); ///< Under Development 
// 		void convertHEXtoRGB(std::string& HEXColor);
		void convertHEXtoRGB(std::string& HEXColor);

		// Beatiful Accsessoris  
			/** Basics **/
		const Tmx::Map*   getrMap()            const { return m_map; }
		const glm::ivec2& getTileLayerPos()    const { return m_tileLayerPosition; }
		const int         getNumTileLayers()   const { return m_numTileLayers; }
		const glm::vec2   getLayerDims()       const { return glm::vec2(m_layerWidth, m_layerHeight); }
  		const int         getMapWidth()        const { return (m_mapTileWidth * m_mapWidth); }
		const int         getMapHeight()       const { return (m_mapTileHeight * m_mapHeight); }
		const int		  getNewMapWidth()	   const { return  (m_newMapTileWidth * m_mapWidth); }
		const int		  getNewMapHeight()    const { return (m_newMapTileHeight * m_mapHeight); }
		const glm::vec2&  getObjectPos()       const { return m_objectPosition; }
		Deep::ColorRGBA8  getBackgroundColor() const { return m_backgroundColor; }
		int               getTilesetIndex(int x, int y) const { return m_tileLayer->GetTileTilesetIndex(x, y); }
		// Return tile Position 
		glm::vec2 getTilePosition(int x, int y) const {
			glm::vec2 pos;
			if (x * y < m_tilesNumber) {
				//puts("Tiles are OK \n");
				pos = glm::vec2(x * m_newMapTileWidth, y * m_newMapTileHeight);
			}
			return pos;
		}
			/** Objects **/
			// Object Position 
		glm::vec2 getObjectPos(const std::string& objectName) const {
			auto it = m_objectsPosition.find(objectName);
			if (it == m_objectsPosition.end()) {
				printf("Object Pos Not Found \n");
				return glm::vec2(0.0f);
			}
			return it->second;
		}
		//Object Dimentions 
		glm::vec2 getObjectDims(const std::string& objectName) const {
			auto it = m_objectsDimensions.find(objectName);
			if (it == m_objectsDimensions.end()) {
				printf("Object Dims Not Found \n");
				return glm::vec2(0.0f);
			}
			return it->second;
		}
		// Object ID & GID | Return: ID >> GID 
		glm::vec2 getObjectID(const std::string& objectName) {
			auto it = m_objectsIDs.find(objectName);
			if (it == m_objectsIDs.end()) {
				printf("Object ID & GID not Found \n");
				return glm::vec2(0.0f);
			}
			return it->second;
		}

	private:   
		
		// SDL Level Drawing 
		void SDLDrawLevel();

		// Private Vars for storing map Data 

		Deep::SpriteBatch m_spriteBatch;

		// Map
		Tmx::Map* m_map = nullptr;
		// Layer
		const Tmx::Layer* m_layer = nullptr;
		// TileSet
		const Tmx::Tileset* m_tileSet = nullptr;
		// Image Layer 
		const Tmx::ImageLayer* m_imageLayer = nullptr;

		// Storing Variables 
			// Map Vars
		double m_mapVersion;
		Tmx::MapOrientation m_mapOrientation;
		std::string m_mapBackgroundColor;
		Tmx::MapRenderOrder m_mapRenderOrder;
		Tmx::MapStaggerAxis m_mapStaggerAxis;
		Tmx::MapStaggerIndex m_mapStaggerIndex;
		int m_mapWidth = 0;
		int m_mapHeight = 0;
		int m_mapTileWidth = 0;
		int m_mapTileHeight = 0;
		int m_newMapTileWidth = 0;
		int m_newMapTileHeight = 0;
		// TileSet Vars
		std::string m_tileSetName;
		int m_tileMargin = 0;
		int m_tileSpacing = 0;
		int m_tileFirstGID = 0;
		unsigned int m_tileID;
		unsigned int m_tileGID;
		// TileSet Image
		const Tmx::Image* m_image = nullptr;
		std::vector<Tmx::Image*> m_images; ///< The vectors of all images 
		int m_imageWidth = 0;
		int m_imageHeight = 0;
		std::string m_imageSource;  ///< stored as C-String 
		std::string m_imageTransparentColor;
		// Tile 
		size_t m_tilesNumber = 0; ///< make sure this will be greater than 0 ... So we can Loop through the tiles 
		Tmx::Tile* m_tile; ///< this hold a single tile from the tileSet ... use Iterator to loop on all the tiles;
		std::map<std::string, std::string> m_tilePropertiesList; ///< store all the tile Poperties || All Tiles Properties
			// Animation 
		bool isAnimated = false; ///< This is used to tell if the tile is animated or no
		int m_frameCount = 0;
		unsigned int m_framesTotalDuration = 0;
		std::vector<Tmx::AnimationFrame> m_animationFrames; ///< this holds all the frames of an Animation || Animations 
		int m_frameTileID = 0; ///< Returned by the iterator;
		unsigned int m_frameDuration = 0; ///< Returned by the iterator;
			// Objects 
		bool m_hasObject = false; ///< if the map Contains an Object || Objects ... DO Somthing 
		const Tmx::Object* m_object = nullptr; ///< a single Object 
		std::string m_objectName;
		int m_objectPositionX = 0;
		int m_objectPositionY = 0;
		int m_objectWidth = 0;
		int m_objectHeight = 0;
		int m_objectID = 0;
		int m_objectGID = 0;
		// Ellipse 
		const Tmx::Ellipse* m_objectEllipse = nullptr;
		glm::vec2 m_objectEllipseCenter;
		glm::vec2 m_objectEllipseRadius;
		// Rectengulare 
		
		//m_object
			// Object Polygon Points 
		//const Tmx::Polygon* m_objectPolygon = nullptr;  ///< Check first if the point != 0;
		//const Tmx::Point  &m_polygonPoint; ///< Returned By GetPoint();
		//const Tmx::Polyline* m_polyLine = nullptr; ///< returned by Object 

		// Layer : Tile Layer
		std::string m_layerName;
		unsigned int m_tileLayerGID = 0;
		glm::ivec2 m_tileLayerPosition;
		int m_numLayers = 0;
		const Tmx::TileLayer* m_tileLayer = nullptr;
		int m_numTileLayers = 0;
		int m_layerWidth = 0;
		int m_layerHeight = 0;
		int m_tileTileSetIndex = 0;
		unsigned int m_layerGID = 0;
		unsigned int m_layerID = 0;
		bool m_isTileFlippedHorizontally = false;
		bool m_isTileFlippedVertically = false;
		bool m_isTileFlippedDiagonally = false;

		// Object Groups
			// Ellipse 

		int m_numObjectGroups = 0;
		const Tmx::ObjectGroup* m_objectGroup = nullptr; ///< Returned By Map
		int m_numObjects = 0; ///< Returned By Object Group
		const Tmx::Object* m_groupObject = nullptr;
		// Info OF : Object from the Group 
		std::string m_groupObjectName;
		glm::vec2 m_objectPosition;
		int m_groupObjectWidth = 0;
		int m_groupObjectHeight = 0;
		// Group Object Polygon 
	//const Tmx::Polygon* m_groupObjectPolygon = nullptr;
	//int m_groupObjectNumPoints = 0;
	//const Tmx::Point m_groupObjectPoint;
	//Tmx::Polyline* m_groupObjectPolyline = nullptr;
	//int m_groupObjectNumPolyline = 0;
	//Tmx::Point* m_groupObjectPolylinePoint = nullptr;

		SDLRenderer* m_SDLRenderer = nullptr;
		TextureManager* m_textureManager = nullptr;
		

		Deep::GLTexture m_texture;
		Deep::DebugRenderer* m_DebugRenderer = nullptr;
		//Deep::LoadUV* m_loadUV = nullptr;
		Deep::Camera2D m_camera;
		//Deep::Camera2D m_tilesCamera;
		Deep::Window* m_window = nullptr;

		std::string m_fileName;
		std::string m_UVFileName;
		std::string m_imageSRC;

		// Convert HEX to RGB Color 
		GLubyte m_red, m_green, m_blue;
		Deep::ColorRGBA8 m_backgroundColor;



		std::mt19937 m_randGenerator;
		std::uniform_real_distribution<float> x_pos;
		std::uniform_real_distribution<float> y_pos;

		glm::ivec2 m_sheetDims;
		Deep::LoadUV* m_loadUV = nullptr;
		Deep::TileSheet* m_sheet = nullptr;

		// Use Weather ID or GID for drawing 
		bool m_useID;

		Deep::SpriteBatch m_backgroundsBatch;

		// Object Data Holders 
		std::map<std::string, glm::vec2> m_objectsPosition;
		std::map<std::string, glm::vec2> m_objectsDimensions;
		std::map<std::string, glm::vec2> m_objectsIDs;
		

		glm::vec2 m_o;

	};

}